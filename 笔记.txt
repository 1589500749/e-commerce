本项目开发所使用的账号  13700000000   密码  111111   只有该账号在服务器端存有可供选择的“收件人列表”
在浏览器中载入vue开发者工具，下载并配置nodejs，管理员打开cmd，配置淘宝镜像，全局安装脚手架，vue create 项目名，关闭eslint，npm run serve启动项目
@符代表src文件夹，这样将来文件过多时找文件方便许多，在css样式中使用@，要在前面加波浪线，“~@”
page文件夹也可写作view文件夹    assets文件夹放置所有组件共用的静态资源
让组件的style标签中能使用less的样式，npm install --save less less-loader@7.3.0，并且在style标签上加属性"lang=less"
注意子组件style标签中加scoped属性,并在public文件中引入清除默认样式的css文件reset.css，记得reset.css的第一行 @import "./iconfont.css"; 由于引用的文件在本地没有，会报错，将其注释掉即可
npm install --save vue-router@3.5.3
配置快速创建vue的组件样式的代码片段
在入口文件main.js中引入所有路由的管理者App.vue和组件路由的管理者./router/index.js
路由组件在router文件夹中注册，在App.vue中通过<router-view>使用
在入口文件中注册完路由器router以后，所有的路由组件和非路由组件上都有了$route和$router属性
路由的跳转有两种形式：声明式导航router-link和编程式导航push/replace，两者的不同在于，编程式导航除了路由跳转外还能做一些其他的业务逻辑
我们可以添加路由的元信息(meta配置项)，根据组件身上的$route来获取当前路由的元信息
以对象形式路由传参（常用),对象的写法可以是name或path形式，但注意path写法不能和params参数一起使用；使用name写法，必须传params，若不传递params则URL会出问题，但可以在占位的后面加"?"来使得params参数可传可不传
params传递的不能是空串，如果是空串可以或一个undefined，this.$router.push({name:'search',params:{keyword:''||undefined}})
编程式导航路由跳转到当前路由(参数不变), 多次执行会抛出NavigationDuplicated的警告错误,可以通过在router的index.js中重写$router.push()和$router.replace()解决。这个警告对程序运行没有任何影响，只是控制台红色不美观而已。
组件中this.$router.push(),this指组件实例，$router指路由器实例，push方法返回的是一个promise对象
组件： 创建，引入，注册，使用
在vue.config.js中配置代理服务器
api文件夹下放axios请求。二次封装axios,配置baseURL、timeout、请求拦截器和响应拦截器。
baseURL会在每一个请求的URL中加上"/api",配置了baseURL以后，代理服务器将  从浏览器接收到的请求路径带有"/api"的   请求转发给服务器
npm i --save nprogress  安装使用进度条模块，引入nprogress和nprogress.css，在请求拦截器中配置start(),在响应拦截器中配置done()  请求发出：进度条开始  响应成功：进度条结束
npm i --save vuex@3.6.2
当组件挂载完毕，通知vuex发请求，获取数据，存储于仓库当中
<div :class"{haha:判断条件}"></div>  这种写法表示的是当判断条件成立时，会给当前div盒子添加上类名为haha的css样式
节流是技能CD，防抖是回城。loadash插件封装了函数的防抖节流的业务(闭包+延时器)
节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发。
防抖：前面的所有触发都被取消，最后一次执行在规定的时间之后才会触发，即如果连续快速的触发，只会执行一次
过渡动画：使用的前提是组件(或元素)必须要有v-if或v-show指令
$store不会出现在vm上，只会出现在组件实例上
点击TypeNav或Header都会跳转到search路由组件，因而在路由跳转时要将两个组件的参数合并一起传给search组件，在TypeNav中合并Header的参数，在Header中合并TypeNav的参数。（合并参数目的在于将导航栏的关键字以及菜单里的分类都传给search组件，便于后端处理分类好的数据给前端展示）
mock数据模拟：安装mockjs，准备json数据(一定要格式化),mock数据需要的图片放入public文件夹(因为public文件夹在打包时会把相应资源原封不动打包到dist文件夹),创建mockSever.js通过mockjs插件实现数据模拟,在入口文件引入mockServe.js,。
webpack默认对外暴露图片和JSON数据格式，所以mock需要的JSON数据不需要export即可直接引入
vue开发者工具中的vuex bindings指的时组件中从vuex拿到的数据
使用swiper：npm i --save swiper@5  ,组件中引包，入口文件中引样式，给出html结构，new一个swiper实例。
如果要给轮播图的div盒子添加标签属性(例如ref等)，一定要写在整个轮播图的最外层盒子上(比如写在含有class='swiper-container'的这个盒子上)
！！！写一个组件功能模块的四大步骤：写静态页面，引入该组件(在router文件夹中引入)，创建该组件的vuex仓库，写api，在组件中发请求获取数据存到vuex,从vuex取数据渲染到页面
vuex仓库中state中的数据的类型不能乱写，取决于服务器返回的数据，若服务器返回数据形式，则state={data1:[]}
如果某个组件需要v-for遍历生成组件实例，那么该组件获取数据的this.$store.dispatch()语句不能放在该组件中，要放在App.vue中，这样就无需每复用一次都发一次数据请求。
！！！标签中使用数据一定要在属性名前加冒号，这样value才不会被当成字符串解析
共用的功能可以拆出来作为一个全局组件，其他组件中在它的组件标签中用props向他传数据就能使用了。
function(a=3)   这种写法意味着若没有传参过来，参数a的默认值为3
object.assign(对象1，对象2，对象3)      该方法将后两个对象合并进第一个对象
post请求中的params参数不能少，至少传一个空对象作为post请求的请求参数,否则数据获取失败，返回的状态码是201
监听属性watch中使用组件实例身上的属性时，不需要在前面加"this."    计算属性computed则一定要加this
使用iconfont:在官网找到图标添加至购物车，再添加到项目，生成font class在线链接，在public文件的index.html用link标签引入，记得herf属性中要写上http协议
v-for也可以遍历数字，从1开始遍历到num; v-if和v-for不能同时使用
@click="$emit('getPageNo',1)"    点击后触发自定义事件
:class="{active:pageNo==totalPage}"   条件成立后active类才会生效
死数据不用v-bind，属性值包含动态的内容
有时由于数据暂未返回，读取不到数据会报红“Cannot read properties of undefined”，这个报红不影响程序正常运行，一般的解决方法是在读取数据的代码语句后面或上一个空对象(或空数组)，这样至少让程序有东西读取到，而不是读取到undefined
在请求拦截器处(request.js)为请求头添加uuid的字段，这样服务器可以识别每次请求来自于哪个用户;同样，token字段的携带也是放在请求拦截器中。
写在事件回调函数里的console.log，要触发事件才能在控制台打印
服务器响应，会生成一个token(cookie)传给用户。token和cookie的区别？
token是有时效性的(后端设置时效性)。
vuex仓库存储数据不是持久化的，刷新后有的数据会丢失。
输入用户名和密码登录成功后，获得服务器传来的token，如果不对token做本地的持久化存储，刷新网页后，vuex仓库里的token会丢失，登录状态也随之退出，需要再次输入用户名密码调用登录接口，从服务器获取token
做了token本地持久化存储以后，即使刷新了网页，vuex仓库也可以从本地存储获取到token,从而保持登录状态,这其实也是“自动登录”功能的实现
路由中的path不区分大小写
不经过vuex也可以发请求，将api文件夹引入到main.js，挂载到vm的原型上，这样所有组件都可以通过this.$API.reqxxxxx来发请求了
不要在例如mounted这样的生命周期函数前用async，解决方法：methods中写一个方法,将mounted中的await移到该方法中，mounted中调用该方法
组件库：  react(vue): antd[PC端]  antd-mobile[移动端]
         vue:  ElementUI[PC端]    vant[移动端]

ElementUI的使用，先npm下载elemetui和 babel-plugin-component(负责按需引入)，接着import { Button, Select } from 'element-ui'引入需要的组件，注册组件的方式有三种(不同的组件注册的方式不一样，要看文档)（1、Vue.use(Button)  2、Vue.component(Button.name, Button)  3、Vue.prototype.$msgbox = MessageBox）
npm i qrcode 二维码生成
children中的二级路由的path,要么带上根文件写全了"/center/myOrder",要么写成"myOrder"；   路由中在children中配置重定向使得跳转到center路由后重新向到"/center/myorder",不需要点击即可自动显示二级路由myorder
"(item,index) in xxx" 用v-for遍历商品列表得到订单表格，收货人这类数据也会被遍历，从而有多余重复的单元格，这是在多余的单元格内标签内加v-if="index==0"
全局路由守卫(写在router文件夹的index.js中)监测每一个路由跳转；独享路由守卫(写在router文件夹的route.js中)只监测一个路由组件；组件内守卫(写在组件实例中)不能获取组件实例“this”,因为守卫执行前，组件实例还未被创建。
npm i vue-lazyload@1.3.3 -S   图片懒加载
路由懒加载：当打包构建应用时，js包会变得非常大，影响页面加载，如果把路由组件分割成不同的代码块，当路由被访问时才加载对应组件，会更加高效
路由懒加载的第一步：定义箭头函数foo    路由懒加载的第二步:路由规则中的组件名改写为 "foo" ，并且import xxx from '@/pages/xxx'这个语句不用写了       这两步也可以合并为一步：路由规则中的组件名直接写为箭头函数"component:()=>import(@/pages/组件名)"

项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错，有了 map 文件就可以像未加密的代码一样，准确的输出是哪一行哪一列有错。但是我们有时候并不需要这个文件，通过以下的设置可以让 Vue 打包的时候不生成 .map 文件，缩小生产环境的包大小。

代理服务器就是位于发起请求的客户端与原始服务器端之间的一台跳板服务器，正向代理可以隐藏客户端，反向代理可以隐藏原始服务器。
